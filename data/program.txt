; PROGRAM 1
; Read in 20 numbers from -32768 to 32767 one at a time
; Enter any number from -32768 to 32767
; The program will print the closest number to the entered number

; LOW MEMORY (6-31): lookup tables for subroutines etc. and some variables
;currently at 21 out of 32 words
        LOC 6
        ; subroutine jump table - currently 1
        JUMPTABLEADDR: Data JUMPTABLE

        ; Constants - currently 8
        MAXVAL:      Data 32767
        DIGIT0:      Data 48
        PERIOD:      Data 46
        MINUS:       Data 45
        ZERO:        Data 0
        ONE:         Data 1
        TEN:         Data 10
        TEMP:        Data 0

        ; Working variables - currently 4
        NUMVAL:      Data 0
        RESULT:      Data 0
        MINDIFF:     Data 0
        CLOSEST:     Data 0


        ;memory address locations - currently 2
        HIGHMEMADDR: Data HIGHMEM
        ARRAYADDR:   Data ARRAY

        ;index register temp store - used to maintain index state after subroutine call
        ;Note: I try to keep a "focus" for each index register. However, in the subroutines,
        ;this will be mostly ignored since the main code index registers are stored and restored
        ;in the subroutine.
        TEMPX1:       Data 0 ;use this mostly for subroutines
        TEMPX2:       Data 0 ;use this mostly for ARRAY
        TEMPX3:       Data 0 ;use this mostly for HIGHNUM

; temp values
        LOC 50
        HIGHMEM:    Data 0

;HIGHMEM LOOKUP TABLE - just using for reference.
; 0 = GUESS
; 1 = DIFF
;READNUM COROUTINE
; 2 = DIGIT for READNUM coroutine
; 3 = TIMES8 for READNUM coroutine
; 4 = TIMES2 for READNUM coroutine
; 5 = ISNEG for READNUM coroutine
; 6 = TEMP for READNUM coroutine
;PARSE COROUTINE - ok to overwrite because they're temp
; 2 = DIG0 for PARSE coroutine
; 3 = DIG1 for PARSE coroutine
; 4 = DIG2 for PARSE coroutine
; 5 = DIG3 for PARSE coroutine
; 6 = DIG4 for PARSE coroutine

;array
        LOC 70
        ARRAY:    Data 0
;jump table
        LOC 500
JUMPTABLE:
        READNUMADDR:         Data READNUM           ;0
        PARSEADDR:           Data PARSE             ;1
        RDCHARADDR:          Data RDCHAR            ;2
        RDDONEADDR:          Data RDDONE            ;3
        POSITADDR:           Data POSIT             ;4
        PR1ADDR:             Data PR1               ;5
        PR2ADDR:             Data PR2               ;6
        POSITIVEADDR:        Data POSITIVE          ;7
        ASCII_TO_DIGIT_ADDR: Data ASCII_TO_DIGIT    ;8
        STORENUMBERADDR:     Data STORENUMBER       ;9

; CODE SECTION: Main program and subroutines
        LOC 100

START:
        ; Load subroutine addresses into index registers
        LDX 1, JUMPTABLEADDR      ;load in the readnum subroutine to get numbers from console

        ; Step 1a. Read number array
        ;TODO: add a loop to read in 20 numbers for the array
        JSR 1, 0, 1                ;this is jumping to READNUMADDR
        LDR 0, 0, RESULT
        LDX 2, ARRAYADDR
        STR 0, 2, 0             ;store address = ARRAYADDR + 0 (to create an array with first value = result of READNUM)

        ; Step 1b. Read guess number
        JSR 1, 0, 1                ;this is jumping to READNUMADDR
        LDR 0, 0, RESULT

        LDX 3, HIGHMEMADDR
        STR 0, 3, 0             ; Store at X3+0 (GUESS)

; compare num array to guess and print out difference
        ;TODO: loop through array and compare to guess, updating closest number each time
        LDR 0, 2, 0             ; R0 = ARRAYADDR + 0 = NUM1

        ; Calculate difference: NUM1 - GUESS
        SMR 0, 3, 0             ; R0 = NUM1 - GUESS (GUESS is at X3+0)
        STR 0, 3, 1             ; STORE DIFF at X3+1 (HIGHNUMADDR + 1 = DIFF)


        ; Get absolute value (if negative, negate)
        JGE 0, 1, 7, 1             ; Skip negation if positive (JUMPTABLE + 7 = POSITIVE)
        NOT 0                   ; Negate
        AIR 0, 1
POSITIVE:
        ;print it out using PARSEADDR
        ;TODO: print out the number that was the cloest to the guess, not the difference
        JSR 1, 1, 1             ;jump to PARSEADDR using indirect

        HLT

; -------------------------coroutines------------------------------
;

; READNUM: Read multiline number terminated by period
READNUM:
        ;index register temp store
        STX 1, TEMPX1
        STX 2, TEMPX2
        STX 3, TEMPX3

        ;start
        LDX 1, JUMPTABLEADDR
        LDX 3, HIGHMEMADDR
        LDR 0, 0, ZERO          ;R0 = 0
        STR 0, 0, NUMVAL        ;NUMVAL = 0
        STR 0, 3, 5             ;Clear ISNEG flag at X3+5

        ; Fall through to RDCHAR

RDCHAR:
        IN 1, 0
        ; Check for period (terminator)
        LDR 2, 0, PERIOD        ;R2 = PERIOD
        TRR 1, 2                ;Set cc(4) = 1 if input = '.', otherwise 0
        JCC 3, 1, 3, 1             ;jump to X1 + 3 (RDDONEADDR) if cc(4) = 1

        ; DEBUG: echo if not terminator
        ; OUT 1, 1

        ; Check if number is negative
        STR 1, 0, TEMP          ; Save input to memory
        LDR 2, 0, TEMP          ; R2 = input (copy via memory)
        SMR 2, 0, MINUS         ;subtract MINUS from input to check for 0 in JNE
        JNE 2, 1, 8, 1             ;jump to ASCII_TO_DIGIT_ADDR if NOT minus

        ;handle minus
        LDR 0, 0, ONE           ;R0 = 1
        STR 0, 3, 5             ;Store 1 at X3+5 (ISNEG flag)
        JMA 1, 2, 1                ;jump to RDCHARADDR (JUMPTABLE + 2)

ASCII_TO_DIGIT:
        ; Convert ASCII to digit
        LDR 2, 0, DIGIT0
        SMR 1, 0, DIGIT0        ;subtract 48 (ASCII '0') from input to get digit
        LDX 3, HIGHMEMADDR
        STR 1, 3, 2             ;store at X3+2 (DIGIT)

        ; Multiply NUMVAL by 10
        LDR 0, 0, NUMVAL
        LDR 2, 0, NUMVAL

        SRC 0, 3, 1, 1           ; times 8 (shift left 3)
        STR 0, 3, 3              ; store at X3+3 (TIMES8)

        SRC 2, 1, 1, 1           ; times 2 (shift left 1)
        STR 2, 3, 4              ; store R2 at X3+3 (TIMES2)

        LDR 0, 3, 3              ; load R0 = TIMES8 (X3+3)

        ; add: R0 + TIMES2 (X3+4) into R0
        AMR 0, 3, 4
        ; add: R0 + DIGIT (X3 + 2) into R0
        AMR 0, 3, 2

        STR 0, 0, NUMVAL

        ; Loop back to RDCHAR (JUMPTABLE + 2)
        JMA 1, 2, 1

RDDONE:
        LDR 0, 0, NUMVAL

        LDR 1, 3, 5             ; Load ISNEG flag from X3+5
        JZ 1, 1, 9, 1              ; If flag is 0, skip negation
        NOT 0                   ; Flip all bits
        AIR 0, 1                ; Add 1 to complete two's complement
STORENUMBER:
        STR 0, 0, RESULT ;store answer in temp result value

        ;reload index register temp store
        LDX 1, TEMPX1
        LDX 2, TEMPX2
        LDX 3, TEMPX3

        ;exit
        RFS 0

; PARSE: Parse and print number (-999 to 999)
; TODO: Extend to handle -32768 to 32767
; TODO: Also, PARSE is currently broken for numbers larger than 10. I think I messed up the parsing logic.
; it prints, but it's usually like some odd ASCII character, implying it's adding a large offset.
PARSE:
        ;index register temp store
        STX 1, TEMPX1
        STX 2, TEMPX2
        STX 3, TEMPX3

        ;load index registers to be safe
        LDX 1, JUMPTABLEADDR
        LDX 3, HIGHMEMADDR

        ; Check if number is 0
        JZ 0, 1, 5, 1          ;jump to PR1ADDR if R0 = 0

        ; Check if number is positive
        LDR 1, 0, ZERO
        JGE 0, 1, 4, 1         ;jump to POSIT if R0 >= 0

        ; Print minus sign
        LDR 1, 0, MINUS
        OUT 1, 1

        ; Negate the number - NOT and add 1 - two's complement
        NOT 0
        AIR 0, 1

POSIT:
        LDR 2, 0, TEN

        ; Extract ones digit
        DVD 0, 2

        LDX 3, HIGHMEMADDR
        STR 1, 3, 2          ;store at X3+2 (DIG0)
        ; TODO: FIX THISSSSSSSSSSSS!!!!!!!!!!!
        ; Check if done (1 digit)
        JZ 0, 1, 5, 1          ;jump to PR1ADDR if R0 >= 0

        ; Extract tens digit
        DVD 0, 2
        STR 1, 3, 3           ;store at X3+3 (DIG1)

        ; Check if done (2 digits)
        JZ 0, 1, 6, 1          ;jump to PR2ADDR if R0 >= 0

        ; extract hundreds digit
        DVD 0, 2
        STR 1, 3, 4            ;store at X2+4 (DIG2)

        ; Check if done (3 digits)
        JZ 0, 1, 6, 1          ;jump to PR2ADDR if R0 >= 0

        ; extract thousands digit
        DVD 0, 2
        STR 1, 3, 5            ;store at X2+5 (DIG3)

        ; Check if done (3 digits)
        JZ 0, 1, 6, 1          ;jump to PR2ADDR if R0 >= 0


        ; Print hundreds
        LDR 1, 3, 4
        AMR 1, 0, DIGIT0
        OUT 1, 1

PR2:
        ; Print tens
        LDR 1, 3, 3         ;load dig1
        AMR 1, 0, DIGIT0
        OUT 1, 1

PR1:
        ; Print ones
        LDR 1, 3, 2         ;load dig0
        AMR 1, 0, DIGIT0
        OUT 1, 1

        ;reload index register temp store
        LDX 1, TEMPX1
        LDX 2, TEMPX2
        LDX 3, TEMPX3

        RFS 0